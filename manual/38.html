<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>さいとうの見える化</title>
<style>
body {
  font-family: "Segoe UI", "Hiragino Sans", "Meiryo", sans-serif;
  background: #fafafa;
  color: #333;
  margin: 40px;
  line-height: 1.6;
}

/* リスト全体 */
ul {
  list-style-type: none;
  padding-left: 0;
  margin-left: 0;
}

/* li 基本デザイン */
li {
  margin: 6px 0;
  padding: 10px 14px;
  background: #fff;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.08);
  position: relative;
  cursor: pointer; /* 読み上げクリックを示す */
}

/* 左線で階層を可視化 */
li li {
  border-left: 3px solid #cce4ff;
  margin-left: 16px;
}

/* 第1階層のタイトル */
body > ul > li {
  background: #0066cc;
  color: #fff;
  font-weight: bold;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  border-left: none;
}

/* 第1階層直下 */
body > ul > li > ul > li {
  background: #fff;
  color: #333;
}

/* リンク */
a {
  text-decoration: none;
  color: #0066cc;
  font-weight: 600;
  font-size: 15px;
}

a:hover {
  text-decoration: underline;
}

/* 階層による文字サイズ調整 */
ul ul li        { font-size: 15px; }
ul ul ul li     { font-size: 14px; }
ul ul ul ul li  { font-size: 13px; }
</style>
</head>
<body>
<ul><li>
<h1>NO TITLE ...</h1>
<br>
このファイルに入っているプログラムは.mrkという、ファイル拡張子が使われるという共通する決まりがあります。</br></br>mrkはmierukaという紐づけのネーミングで、このファイルの処理は本体からの見える化処理をした際に、.html等の内容で、見える化する時にそれぞれ、個別に呼ばれます。</br></br>もちろんですが、本体側からは、フォルダ以下全て見える化を行えるので、機能毎に何度も、呼ばれる場合もあります。
</li>
<li>
<h1>NO TITLE ...</h1>
<br>
methodというフォルダを作ると…。</br></br>その中に、機能の画面（top.srk等）で2つや3つやたくさん同じ処理をどの画面でも使うんで、めんどくさいや！</br></br>って時があると思います。</br></br>その時に共通する処理をここに保存することができます。</br></br>methodフォルダの中のメソッドの書かれたファイルに関しては、.trkと言う拡張子をつけるという、ファイル名のルールがあります。</br></br>あと、このファイルの書き方のサンプルは…。</br></br>method_memo(@string list){</br></br>@string dp = @thisPath();</br>@string dp2 = dp + "/" + list;</br></br>}end_method_memo;</br></br>このような感じです。</br></br>言語理解のある人は、ピントくると思うので、説明がいらないと思いますが…。</br></br>基本的に、ファイル名のmemo.trkだったら、method_memo(@string list){</br></br>の部分のmemoがファイル名と同じになります。</br></br>引数という@string listの部分は、メソッドの呼び側から、受け取る窓口であり、@stringはその受け取る変数の種類です。</br></br>listに関しては、実際に受け取る変数の名前、移行メソッドプログラムの中では、listという物が受け取れます。</br></br>メソッドの言語種類に関しては、serika言語が使えます。</br></br>最後になりますが、</br>}end_method_memo;</br>に関しては、最終的に、end_methodで終わらせるという意味で、必ず、_memoという、_ファイル名がつけられます。
</li>
<li>
<h1>NO TITLE ...</h1>
<br>
ひとつの機能毎には、少しだけルールがあります。</br></br>まず、機能毎のフォルダのネーミングについては、このホームページの一個上のカテゴリの、</br>2.appについて</br>のセクションの中のどこかで、歌っていると記憶していますが…。</br></br>とにかく、taka.noteだったら、takaの部分が、作った人のアカウントＩＤが使われています。</br></br>ＩＤはユニーク（一つしか存在しない）ですので、その時点で名前がラップすることはないわけです。</br></br>それは、厳密にいうと色々ありますが…。</br></br>それさておいて、その下の、内容を説明します。</br></br>prop.setという、ファイルが存在します。</br></br>これは、機能のフォルダのルート（一番上の親玉フォルダ）の下に置かれています。</br></br>このファイルは、説明すると、機能の名札というような感じです。</br></br>この機能自体が私ですとすると。</br></br>私は、なになに会社の、なになに部の、だれだれさんという名前です。</br></br>私は、これこれこういったことができます。</br></br>という二つの内容のことが記載されています。</br></br>ちなみに、ここで、.setという拡張子が出てきます。</br></br>ちなみに、.setは何度も出てきますが、settingという所謂(設定)という意味付けです。</br></br>コンテンツ(.txt等)ではなくて、どちらかというと、違った意味のファイルという意味です。</br></br>もちろん、テキストで書かれては居るわけですが、問題は内容の種類とか重みが違いますよーっていう位置づけです。</br></br>ちなみに、top.srkというもや.srkとついている物に関しては、何なのか？というと、これが実は実際の機能です。</br></br>ちなみにもう一つ進めるならば、.srkの一つのファイルが、一つの画面の単位です。</br></br>この、ファイルがあるから機能がそこに書き込まれ間れているので、起動する訳です。</br></br>あと、top.srkに関しては、特別です。</br></br>特別と言っても、単に、機能が一番最初にどの画面を起動するのか？という時に、最初にtop.srkが選ばれるという意味だけです。</br></br>とにかく、最初に呼ばれて表示されます。
</li>
<li>
<h1>NO TITLE ...</h1>
<br>
自分で作った機能を誰かと共有したかったりすると思います。</br></br>そういう方は</br></br>設定 > その他 > 更新関係 > アップロードする</br></br>をおしてください。</br></br>ちなみに、注意点！！！！</br></br>機能を作る時は、</br>個人のIDがありきですので！</br></br>IDがあると</br></br>IDname.appname</br></br>という形になります。</br></br>どういうことかというと、idは、誰ともかぶらないので、idはオリジナルです。</br></br>いわゆる、その機能は、唯一無二の名前が割与えられるわけで、どの機能にも上書きはされません。</br></br>でないと、やばいですよねｗ
</li>
<li>
<h1>NO TITLE ...</h1>
<br>
とはいっても、あらかた自動化してあります。</br></br>IDは</br>taka.mkkinou</br>です。</br></br>情報処理 > 自動化 > serika機能作成</br></br>がそれです。</br></br>これで大方作れます。</br></br>色々と、マニュアル読んで覚えるよりも、あらかた作られたソースを見た方が、わかるようです。
</li>
<li>
<h1>NO TITLE ...</h1>
<br>
オブジェクトにはそれぞれおしたとき、右クリックしたとき、色々とそれぞれにおいて、ふるまいを加えられます。</br></br>書き方は、trgタグの中に書きます。</br></br>trgタグは、objectのそれぞれのタグの中に書きます。</br></br>属性は、noだけです。</br></br>no="0"とすると大抵は左クリックです。</br></br>no="1"は大抵右クリック時です。</br></br>あ！</br></br>ちなみに安易にタグと言っていますが、タグなので、trgタグというのはもちろん<trg>と言う書式です。</br></br>HTMLを知ってると大抵同じだなって感じです。</br></br>それと、肝心のふるまいについての書式ですが…！</br></br>これはserika言語になりますので、別で書きます。
</li>
<li>
<h1>NO TITLE ...</h1>
<br>
フレームのテキストは、全てタグで作られます。</br></br>要はオリジナルのXML形式のタグ情報で作られるってことです。</br></br>一番外のタグはframeタグです。</br></br>その中にはobjectタグとsetタグがあります。</br></br>frameタグには、画面が配置される場所や、大きさが決められます。</br></br>objectタグにはそのフレームに表示されるボタンや、リストボックス等の、俗にいうオブジェクトタグが入ります。</br></br>それと、同じく一番下の最後の行に、setタグが入ります。</br>setタグというのは、最初に呼ばれた時になんにせよ、一番最初に起動するモノを書きます。</br></br>例えば、オブジェクトに表示するのに必要なリスト内容のテキストを、判定したり、判断したりして、保存したりします。</br></br>セットタグ読み込み完了後、上のオブジェクトタグから、フレームに表示していきます。</br></br>オブジェクト情報は、type属性、text属性、size属性、tool属性があります。</br></br>それぞれ例えば、typeだったら、type=""と書きます。</br></br>最初と最後には半角スペースで隙間を明けます。</br></br>あ！</br></br>ちなみに、タグの範囲が終わったら、閉じタグ</tagname>で閉じますからね！</br></br>ちなみに、これで、大体の機能は作れます。
</li>
<li>
<h1>NO TITLE ...</h1>
<br>
画面は…このserika言語は、インタプリンター言語です。</br></br>ちなみに、本体のserika.jarには、本体の８つのフォルダや機能を起動するボタンから機能を呼び出すことができます。</br></br>その８個のボタンは最初にフォルダとして、認識します。</br></br>何故なら、appは全て、一個のフォルダをそれぞれ持つからです。</br></br>しかし、そのフォルダと同じ名前の.setというファイルが同じ場所にあって、その中にnet.axwork/apps/[appsname]の名前と同じテキストが存在したならば、その機能のtop.srkが呼ばれて起動します。</br></br>appsname=[フォルダと同じ名前.set]の内容</br></br>ですが、あくまで、appsの機能毎にそれぞれの、現在のフォルダの内容と情報をやり取りします。</br></br>いわゆる、エクセルやワードのように、エクセルはそれはそれ、エクセルのデータ自体は、どこにあってもそれは、それって感じです。</br></br>もちろん、このserika.jar自体は、これで言うのであれば、オリジナルの、エクセル自体を作れるということになりますが。
</li>
<li>
<h1>NO TITLE ...</h1>
<br>
0
</li>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const lis = document.querySelectorAll("li");

  lis.forEach(li => {
    li.addEventListener("click", (event) => {
      event.stopPropagation();  // 親の読み上げを防ぐ

      // 読み上げテキストを取得
      let text = li.innerText.replace(/\s+/g, " ").trim();

      // リンクがあると URL まで読むので前処理
      const a = li.querySelector("a");
      if (a) {
        text = a.textContent.trim();
      }

      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = "ja-JP";
      speechSynthesis.cancel(); // 前のを停止
      speechSynthesis.speak(utter);
    });
  });
});
</script>
</body>
</html>